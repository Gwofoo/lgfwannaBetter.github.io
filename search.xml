<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++常用库函数]]></title>
    <url>%2F2019%2F11%2F22%2Fc-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123isalpha(字母); //判断是否是字母toupper(字母); //转大写tolower(字母); //转小写]]></content>
      <tags>
        <tag>Learning</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector应用-ccf1712-2围圈报数]]></title>
    <url>%2F2019%2F09%2F07%2Fvector%E5%BA%94%E7%94%A8-ccf1712-2%E5%9B%B4%E5%9C%88%E6%8A%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述​ 1到n号小朋友顺时针坐一圈，围圈报数。​ 若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰。 ​ 当只剩一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入5 2 样例输出3 样例输入7 3 样例输出4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 分析应用vector和迭代器。 12vector&lt;int&gt;v;vector&lt;int&gt;::iterator it; 开始时，迭代器指向v.begin()，当迭代到v.end()时，重新指向v.begin()，从而做到循环。 当v.size()==1时退出循环。 循环时，若报数报到淘汰值，直接将该元素移出vector：v.erase(it); 。 code123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int a[1005]=&#123;0&#125;; //0游戏中，1出局 int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; vector&lt;int&gt;v; vector&lt;int&gt;::iterator it; //各号小朋友就位 for(int i=1;i&lt;=n;i++)&#123; v.push_back(i); &#125; //游戏开始 int count=0;//报的数 for(it=v.begin();v.size()!=1;)&#123; //vector中晋仅剩一个元素时游戏结束 //迭代器报到末尾，则从头开始报 if(it==v.end()) it=v.begin(); count++; if(count%10==k || count%k==0)&#123; //尾号为k 或 k的倍数 //cout&lt;&lt;*it&lt;&lt;"被淘汰"&lt;&lt;endl; v.erase(it); continue; //删除元素后,后面元素自动往前移，所以迭代器不要增加了！ &#125; it++; &#125; cout&lt;&lt;v[0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack应用-ccf201903-2二十四点]]></title>
    <url>%2F2019%2F09%2F07%2Fstack%E5%BA%94%E7%94%A8-ccf201903-2%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目背景二十四点：使用 3 个加减乘除运算使得 4张纸牌上数字的运算结果为 24。 题目描述定义每一个游戏由 4 个从 1-9 的数字和 3个四则运算符组成，保证四则运算符将数字两两隔开，不存在括号和其他字符，运算顺序按照四则运算顺序进行。 其中加法用符号 + 表示，减法用符号 -表示，乘法用小写字母 x 表示，除法用符号 / 表示。在游戏里除法为整除，例如 2 / 3 = 0，3 / 2 = 1, 4 / 2 = 2。老师给了你 n 个游戏的解，请你编写程序验证每个游戏的结果是否为 24 。 输入格式从标准输入读入数据。 第一行输入一个整数 n，从第 2 行开始到第 n + 1 行中，每一行包含一个长度为 7的字符串，为上述的 24 点游戏，保证数据格式合法。 输出格式输出到标准输出。 包含 n 行，对于每一个游戏，如果其结果为 24 则输出字符串 Yes，否则输出字符串 No。 样例输入1234567891011109+3+4x35+4x5x57-9-9+85x6/5x43+5+7+91x1+9-91x9-5/98/5+6x96x7-3x66x4+4/5 样例输出12345678910YesNoNoYesYesNoNoNoYesYes 分析使用stack。 先读入第一个数字，入栈。 然后是3次循环，每次循环读一个符号和一个数字。 在一次循环中，读的符号若为 x 或 / ，则弹出栈顶数字，将其与下一位数字作相应运算后再入栈；读的符号若为 + 或 - ，则下一位数字直接入栈，注意：若符号为 - ，入栈时入的是相反数（便于最后一次性相加）。 循环结束后，将栈内剩余的数字依次弹出相加。若为24，则Yes。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--)&#123; stack&lt;int&gt; s; int a,b; //读第一个数字，直接push cin&gt;&gt;a; s.push(a); for(int i=0;i&lt;3;i++)&#123; //读一个符号 char c; cin&gt;&gt;c; //读一个数字 cin&gt;&gt;a; int sum; //sum存储乘除运算的中间结果 if(c=='x')&#123; sum=a*s.top(); s.pop(); s.push(sum); &#125; else if(c=='/') &#123; sum=s.top()/a; s.pop(); s.push(sum); &#125; else if(c=='+')&#123; s.push(a); &#125; else&#123; s.push(a*(-1)); &#125; &#125; int count=0; while (!s.empty())&#123; count+=s.top(); //依次弹出相加 s.pop(); &#125; //cout&lt;&lt;count&lt;&lt;endl; if(count==24)&#123; cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1262 寻找素数对(我用了vector迭代)]]></title>
    <url>%2F2019%2F08%2F04%2FHDU1262-%E5%AF%BB%E6%89%BE%E7%B4%A0%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[Description任意取一个偶数,寻找两个素数,使得其和等于该偶数. 要求所寻找的素数对是两个值最相近的. Input输入中是一些偶整数M(5&lt;M&lt;=10000). Output对于每个偶数,输出两个彼此最接近的素数,其和等于该偶数. Sample Input120 30 40 Sample Output1237 1313 1717 23 Code1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v; //存储素数vector&lt;int&gt;::iterator it;bool isPrime(int n)&#123; for(int i=2;i&lt;=n/2;i++)&#123; if(n%i==0) return false; &#125; return true;&#125;void generatePrimes()&#123; for(int i=3;i&lt;10000;i++)&#123; if(isPrime(i))&#123; v.push_back(i); //素数压入vector &#125; &#125;&#125;int main()&#123; generatePrimes(); //先 生成题目范围内的素数 int m; while(cin&gt;&gt;m)&#123; int x,y; for(int i=0;i&lt;v.size();i++)&#123; int t=m-v[i]; for(it=v.begin()+i;it!=v.end();it++)&#123; if(*it==t)&#123; //由于有多个符合条件的素数对，每次都将x,y重新覆盖，即取最后一次结果 x=v[i]; y=t; &#125; &#125; &#125; cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ STL]]></title>
    <url>%2F2019%2F08%2F04%2Fc-STL%2F</url>
    <content type="text"><![CDATA[map123456789101112131415161718#include&lt;map&gt;map&lt;int, string&gt; stu; // 定义一个map对象map&lt;int, string&gt;::iterator it; //定义相应的迭代器（用于遍历）//插入元素：用"array"方式插入stu[123] = "student_first";stu[456] = "student_second";//迭代for(it=stu.begin();it!=stu.end();it++)&#123; cout&lt;&lt;it-&gt;first; //first表示key cout&lt;&lt;it-&gt;second; //second表示value&#125;/* map.count(Key)返回值为1或者0，1返回存在，0返回不存在。因为在map中数据的Key值都是不同的，所以被count的数要么存在1次，要么不存在。 begin()指向第一个元素 end()指向最后一个元素的后一个元素*/ setset即数学上的集合——每个元素最多只出现一次。 1.头文件1#include &lt;set&gt; 2.常用操作12345678910111213141516set&lt;int&gt; s s.size() //集合中元素的数目s.clear() //清除所有元素s.count() //返回某个值元素的个数s.empty() //如果集合为空，返回trues.begin() //返回指向第一个元素的迭代器s.end() //返回指向最后一个元素之后的迭代器，不是最后一个元素s.erase() //删除集合中的元素s.find() //返回一个指向被查找到元素的迭代器，如果没找到则返回end()s.insert() //在集合中插入元素s.swap() //交换两个集合变量 3.例子：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt;::iterator it;int main()&#123; //插入10个元素 for(int i=0; i&lt;10; i++)&#123; s.insert(i); &#125; //打印10个元素 for(it=s.begin(); it!=s.end(); it++)&#123; cout&lt;&lt;*it&lt;&lt;" "; &#125; cout&lt;&lt;endl; s.erase(5); if(s.insert(3).second)//把3插入到s中,插入成功则s.insert(3).second返回1，否则返回0. cout&lt;&lt;"插入成功"&lt;&lt;endl; else cout&lt;&lt;"插入失败"&lt;&lt;endl; // √ for(it=s.begin(); it!=s.end(); it++) cout&lt;&lt;*it&lt;&lt;" "; s.clear(); return 0;&#125; vector12345678910111213141516#include&lt;vector&gt;vector&lt;int&gt; c;c.pop_back(); // 删除最后一个数据。c.push_back(elem); // 在尾部加入一个数据。c.front() // 传回第一个数据c.back() // 传回最后一个数据c.erase(pos) // 删除pos位置的数据，传回下一个数据的位置。c.insert(pos,elem) // 在pos位置插入一个elem拷贝，传回新数据位置。c.size() // 返回容器中实际数据的个数。c.resize(num) // 改变vector大小c.clear() // 移除容器中所有数据。c.empty() // 判断容器是否为空。 queue1234567891011121314#include&lt;queue&gt;queue&lt;int&gt; q1;queue&lt;double&gt; q2;q.push(x); //将x 接到队列的末端。q.pop(); //弹出队列的第一个元素，注意，没有返回值！q.front(); //即最早被压入队列的元素。q.back(); //即最后被压入队列的元素。q.size(); q.empty(); //当队列空时，返回true。//若要取完队头元素后删之，需front()和pop()连用 优先队列介绍优先队列有点像队列，但优先队列的出队元素，不是最先进队的元素，而是优先级最高的元素。（这样就可以允许类似“急诊病人插队”这样的事情发生。） 由于不是先进先出，所以出队的方法由front()变为top()。 自定义类型也可以组成优先队列，但必须为每个元素定义一个优先级（这个“优先级”只需要能比较大小即可）。 头文件1#include&lt;queue&gt; 使用1priority_queue&lt;int&gt; pq; //越大的整数优先级越高]]></content>
      <tags>
        <tag>Learning</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1263 水果进货单整合(二维map)]]></title>
    <url>%2F2019%2F08%2F04%2FHDU1263-%E6%B0%B4%E6%9E%9C%E8%BF%9B%E8%B4%A7%E5%8D%95%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[DescriptionJoe经营着一个水果店.现在他想要一份水果销售情况的明细表. Input第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成. Output对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.两组测试数据之间有一个空行.最后一组测试数据之后没有空行. Sample Input123456715apple shandong 3pineapple guangdong 1sugarcane guangdong 1pineapple guangdong 3pineapple guangdong 1 Sample Output12345guangdong |----pineapple(5) |----sugarcane(1)shandong |----apple(3) Analysis用二维map~ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;int main()&#123; int N; cin&gt;&gt;N; while(N--)&#123; map&lt;string,map&lt;string,int&gt;&gt; fruit; //创建二维map map&lt;string,map&lt;string,int&gt;&gt;::iterator it; //产地迭代 map&lt;string,int&gt;::iterator iter; //水果迭代 int M; cin&gt;&gt;M; string place,name; int num; while(M--)&#123; cin&gt;&gt;name&gt;&gt;place&gt;&gt;num; fruit[place][name]+=num; &#125; //迭代产地 for(it=fruit.begin();it!=fruit.end();it++)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;endl; //迭代该产地的水果 for(iter=it-&gt;second.begin();iter!=it-&gt;second.end();iter++)&#123; cout&lt;&lt;" |----"&lt;&lt;iter-&gt;first&lt;&lt;"("&lt;&lt;iter-&gt;second&lt;&lt;")"&lt;&lt;endl; &#125; &#125; //若不是最后一个实例，则打印一空行 if(N) &#123; cout&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1265 浮点转换]]></title>
    <url>%2F2019%2F08%2F04%2FHDU1265-%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[原题链接http://icpc.njust.edu.cn/Problem/Hdu/1265/ Description将实s数转换为IEEE单精度浮点数表示。 Input先输入一个数N(1&lt;=N&lt;=150)，表示实例个数；其后是N个实数。 Output输出IEEE浮点表示，字母大写。 Sample Input123223.85-23.85 Sample Output1241BECCCDC1BECCCD Analysis一个巧妙的办法，将浮点数的4个字节32位的内存空间copy给整数ans， 然后以16进制的方式打印整数ans 即可； 变量ans使用long或unsigned int，因为有32位，如果用int，32位有一位表示正负，只有31位可用，会不够。 Code1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; long n,ans; float f; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;f; memcpy(&amp;ans,&amp;f,4); //将f的4个字节复制到ans printf("%lX\n",ans); //16进制long，且为大写 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1264 数矩形方格]]></title>
    <url>%2F2019%2F08%2F03%2FHDU1264-%E6%95%B0%E7%9F%A9%E5%BD%A2%E6%96%B9%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[原题链接http://icpc.njust.edu.cn/Problem/Hdu/1264/ Description每一行输入一个矩形 ，该矩形用两个对角坐标(X,Y)来表示位置（所有坐标范围是0-100的整数）。 例如，5 8 7 10表示该矩形4个顶点是(5,8),(7,8),(7,10),(5,10)。该矩形覆盖了4个单位1*1的方格。 求：若干矩形共覆盖了多少个方格？（重复覆盖只算一次） Input输入若干行，每行包含4个整数，依次表示两个对角坐标。 输入4个-1用以分隔每个实例，输入4个-2用以结束最后一个实例。 Output输出所覆盖的方格数。每个结果占单独一行。 Sample Input123456785 8 7 106 9 7 86 8 8 11-1 -1 -1 -10 0 100 10050 75 12 9039 42 57 73-2 -2 -2 -2 Sample Output12810000 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int p[101][101]; //保存所有方格状态的数组，0:没算过；1:算过int main()&#123; int a,b,c,d; int count=0; memset(p,0,sizeof(p)); while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d &amp;&amp; !(a==-2 &amp;&amp; b==-2 &amp;&amp; c==-2 &amp;&amp; d==-2))&#123; if(a==-1 &amp;&amp; b==-1 &amp;&amp; c==-1 &amp;&amp; d==-1)&#123; cout&lt;&lt;count&lt;&lt;endl; count=0; memset(p,0,sizeof(p)); continue; &#125; //调整输入坐标，使得对角从小到大 if(a&lt;c&amp;&amp;b&gt;d)&#123; swap(b,d); &#125; if(a&gt;c&amp;&amp;b&gt;d)&#123; swap(a,c); swap(b,d); &#125; if(a&gt;c&amp;&amp;b&lt;d)&#123; swap(a,c); &#125; //将坐标化为一个个网格，遍历网格，数格子 for(int i=a;i&lt;c;i++)&#123; for(int j=b;j&lt;d;j++)&#123; if(p[i][j]==0)&#123; count++; p[i][j]=1; &#125; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++文件读写 字符串]]></title>
    <url>%2F2019%2F07%2F09%2Fc-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[文件输入输出使用重定向用freopen可以直接变成由文件输入输出： 123456789101112131415#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; freopen("in.txt","r",stdin); freopen("out.txt","w",stdout); //如果不存在，将创建 printf("ooo\n"); cout&lt;&lt;"123"&lt;&lt;endl; //以上两种方式都可以将数据直接写入out.txt文件 //每次运行，out.txt会被重写 return 0;&#125; 重定向方式写起来简单自然，但是不能同时读写文件和标准输入输出。 使用fopen1234567891011121314#include&lt;stdio.h&gt;int main()&#123; FILE *fin,*fout; //定义两个文件指针 fin = fopen("in.txt","rb"); //"rb"表示二进制文件只读 fout = fopen("out.txt","wb"); int n; fscanf(fin,"%d",&amp;n); //指定由fin读入整数n fprintf(fout,"%d",n); //指定将n输出到fout中 return 0;&#125; 常见的字符串函数的用法1.tolower(ch)把字符转换成小写字母，非字母字符不做处理 123456char ch[5]=&#123;'a','B','C','d'&#125;; char lower_ch[5]; for(int i=0;i&lt;5;i++)&#123; lower_ch[i]=tolower(ch[i]); cout&lt;&lt;lower_ch[i]; &#125; //输出：abcd 2.strtok(str,&quot;,&quot;)以逗号为分隔符，将str切分成一个个子串 12345char ch[16] = "abc,d"; char *p; p = strtok(ch, ","); printf("%s\n", p); //输出：abc (换行）d 3.substr(开始下标，长度) 12345678string s1="My name is Ariel.";string s2 = s1.substr(1,3);cout&lt;&lt;"s2="&lt;&lt;s2&lt;&lt;endl;string s3=s1.substr(4);cout&lt;&lt;"s3="&lt;&lt;s2&lt;&lt;endl;//输出：s2=Y n// s3=ame is Ariel. 4.insert(开始下标，str) 123string s1="hello";string s2 = "Ariel!";s1.insert(2,s2);//输出：heAriel!llo 5.erase(开始下标，长度count)从开始下标起，删除count个字符。如果现有长度少于count或count为-1，则删到串尾。默认情况下,开始下标为0；默认删除到串尾。 6.int find_first_of(char c, int start = 0):查找字符串中第1个出现的c,由位置start开始。如果有匹配，则返回匹配位置；否则，返回-1.默认情况下，start为0。 7.int find_last_of(char c):找字符串中最后一个出现的c。有匹配，则返回匹配位置；否则返回-1. ​]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习笔记]]></title>
    <url>%2F2019%2F07%2F07%2Fjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[分号在 JavaScript 中，用分号来结束语句是可选的。 对代码行进行拆行可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示： 12document.write("你好 \世界!"); 不过，不能像这样拆行： 12document.write \ ("你好世界!"); 注释采用 // 和 /* */ 两种。 变量声明JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。 当您声明新变量时，可以使用 “new” 来声明其类型（首字母大写）： 12345var carname = new String; //字符串var x = new Number; //数字 var y = new Boolean; //布尔var cars = new Array; //数组var person = new Object; //对象 赋值1var x,y,z=1; x, y 为 undefined， z 为 1。 重新声明如果重新声明 JavaScript 变量，该变量的值不会丢失： 12var carname="Volvo"; var carname; 两条语句执行后，变量 carname 的值依然是 “Volvo”。 生存期局部变量（函数内的变量，只能在函数内部访问它）会在函数运行以后被删除。 全局变量（函数外的变量，网页上的所有脚本和函数都能访问它）会在页面关闭后被删除。 向未声明的 JavaScript 变量分配值如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 这条语句： 1carname="Volvo"; 将声明 window 的一个属性 carname。 非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。 123456789101112var var1 = 1; // 不可配置全局属性var2 = 2; // 没有使用 var 声明，可配置全局属性console.log(this.var1); // 1console.log(window.var1); // 1delete var1; // false 无法删除console.log(var1); //1delete var2; console.log(delete var2); // trueconsole.log(var2); // 已经删除 报错变量未定义 数组创建名为 cars 的数组： 1234var cars=new Array();cars[0]="Saab";cars[1]="Volvo";cars[2]="BMW"; 或者 (condensed array，压缩数组): 1var cars=new Array("Saab","Volvo","BMW"); 或者 (literal array，文本数组): 1var cars=["Saab","Volvo","BMW"]; 对象对象由花括号分隔。对象的属性以 name : value 的形式来定义。属性由逗号分隔： 123456789var person=&#123; firstname : "John", //在对象中写属性 lastname : "Doe", id : 5566, fullName : function() //在对象中写方法 &#123; return this.firstName + " " + this.lastName; &#125;&#125;; 对象属性有两种寻址方式： 12name = person.lastname;name = person["lastname"]; 调用对象的方法： 123456name = person.fullName(); //执行函数，返回：John Doename = person.fullName; //返回：function() &#123; return this.firstName + " " + this.lastName; &#125;//调用方法时，不加括号，返回的是函数代码（相当于把方法看成属性了） undefined 、null、typeofundefined ： ​ 表示变量不含有值。 ​ 是所有没有赋值变量的默认值，自动赋值。 null： ​ 可以将变量的值设置为 null 来清空变量。 ​ 主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 可以使用 typeof 操作符来检测变量的数据类型。 123456//null 和 undefined 的值相等，但类型不等：typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 函数函数变量变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 12345// 此处可调用 carName 变量 function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量 &#125; 该例中， carName 在函数内，但是为全局变量。 匿名函数函数存储在变量中，不需要函数名称，通常通过变量名来调用。 12var x = function (a, b) &#123;return a * b&#125;;var z = x(4, 3); 自调用函数（还不太理解）函数表达式可以 “自调用”。 自调用表达式会自动调用。 如果表达式后面紧跟 () ，则会自动调用。 不能自调用声明的函数。 通过添加括号，来说明它是一个函数表达式： 123(function () &#123; var x = "Hello!!"; // 我将调用自己&#125;)(); 以上函数实际上是一个 匿名自我调用的函数 (没有函数名)。 JavaScript 闭包实例 1234567var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125; &#125;)(); add(); add(); add(); // 计数器为 3 实例解析 变量 add 指定了函数自我调用的返回字值。 自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。 add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 计数器受匿名函数的作用域保护，只能通过 add 方法修改。函数是对象 在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。 箭头函数ES6 新增了箭头函数。箭头函数的语法比普通函数更简洁。 1234(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125; 当只有一个参数时，圆括号是可选的： 12(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125; 没有参数的函数应该写成一对圆括号: 1() =&gt; &#123;函数声明&#125; 实例： 123456// ES5 var x = function(x, y) &#123; return x * y; &#125; // ES6 const x = (x, y) =&gt; x * y; 参数规则显式参数（形参）、隐式参数（实参） JavaScript 函数定义显式参数时没有指定数据类型。 JavaScript 函数对隐式参数没有进行类型检测。 JavaScript 函数对隐式参数的个数没有进行检测。 let关键字let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。 let 和 var 的区别代码实例： 1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量: 1234567var x = 2; // 合法let x = 3; // 不合法&#123; var x = 4; // 合法 let x = 5 // 不合法&#125; const关键字使用 const 声明的是常量，其值一旦被设定便不可被更改。 常见的HTML事件下面是一些常见的HTML事件的列表: 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 字符串字符串可以是对象通常， JavaScript 字符串是原始值，可以使用字符创建： 1var x = "John" 但我们也可以使用 new 关键字将字符串定义为一个对象： 1var y = new String("John") 12typeof x // 返回 Stringtypeof y // 返回 Object 建议：不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用： 12345678var x = "John"; var y = new String("John");(x === y) /* 结果为 false，因为 x 是字符串，y 是对象 === 为绝对相等，即数据类型与值都必须相等。*/ 关于更多字符串对象，请访问菜鸟String对象 For/In 循环for/in 语句循环遍历对象的属性： 123456var person=&#123;fname:"John",lname:"Doe",age:25&#125;; for (x in person) &#123; // x 为属性名 txt=txt + person[x]; &#125;//txt最终为：JohnDoe25 js数据类型在 JavaScript 中有 5 种不同的数据类型： string number boolean object function 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined 请注意： NaN 的数据类型是 number 数组(Array)的数据类型是 object 日期(Date)的数据类型为 object null 的数据类型是 object 未定义变量的数据类型为 undefined 类型转换123456789101112String(x) // 将变量 x 转换为字符串并返回x.toString()Number("3.14") // 返回 3.14Number(" ") // 返回 0 Number("") // 返回 0Number("99 88") // 返回 NaN5 + null // 返回 5 null 转换为 0"5" + null // 返回"5null" null 转换为 "null""5" + 1 // 返回 "51" 1 转换为 "1" "5" - 1 // 返回 4 "5" 转换为 5 提升（hoisting）提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的行为。提升（Hoisting）应用在变量的声明与函数的声明。 变量提升JavaScript 中，函数及变量的声明总是会被解释器悄悄地被”提升”到函数的最顶部。也就是说，哪怕变量在使用后才声明，也没事（有声明就好~）。 但 声明的时候顺便初始化了（如var y = 7;），此时不会被“提升”。 函数提升函数可以在声明之前调用： 12345myFunction(5); //先调用function myFunction(y) &#123; //再声明 return y * y;&#125; 使用表达式定义函数时无法提升。 “use strict”JavaScript 严格模式（strict mode）即在严格的条件下运行。 实例1 123456"use strict";myFunction();function myFunction() &#123; y = 3.14; // 报错 (y 未定义)&#125; 实例2 1234567x = 3.14; // 不报错 myFunction();function myFunction() &#123; "use strict"; y = 3.14; // 报错 (y 未定义)&#125; 为什么使用严格模式: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 更多限制，点击此处 浮点型数据JavaScript 中的所有数据都是以 64 位浮点型数据(float) 来存储。 所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定： 1234var x = 0.1;var y = 0.2;var z = x + y // z 的结果为 0.3if (z == 0.3) // 返回 false JavaScript 表单JavaScript 表单]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Helper]]></title>
    <url>%2F2019%2F07%2F04%2FMarkdown-Helper%2F</url>
    <content type="text"><![CDATA[Markdown是一种神奇的标记语言，对我这种格式强迫症患者具有很好的治疗效果！通过简单的标记语法，它可以使普通文本内容具有一定的格式。以下是日常使用总结，持续更新~ Markdown 需要转义的字符123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT Helper]]></title>
    <url>%2F2019%2F07%2F04%2FNexT-Helper%2F</url>
    <content type="text"><![CDATA[嘻嘻！装了我很喜欢的也是几乎最热门的主题NexT，但是相关配置还是花了一点时间，现在将一些主要设置写于此博客\便于日后修改~ 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。以下设置大部分是对该文件的设置。 1、文章设置给文章增加标签打开文章的.md文件，在最上面写上： 1234title: 文章名称tags: - Tag1 - Tag2 禁用评论打开文章的.md文件，在最上面写上： 1comments: false 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供选择。 默认使用的是 白色的 normal 主题，可选的值有 : normal，night， night blue， night bright， night eighties, 如下图所示： 修改：在NexT下的_config.yml中设置 1highlight_theme: normal 添加阅读全文按钮只需在文章中你想截止的地方添加 1&lt;!--more--&gt; 2、菜单设置添加模块123456789menu: home: / || home //首页，默认 archives: /archives/ || archive //归档，默认 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 不需要哪个就将其注释掉。 仅仅这设置的话点击后会类似于404，还要添加相应的页面语句。在blog根目录右键打开git bash，利用 123$ hexo new page tags ::新建标签$ hexo new page categories ::新建分类$ hexo new page about ::新建关于 在blog/sourse/下新建相关文件。 添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 3、主题设置我设置的是 pieces， 共有4中可选，默认是Muse。 12345# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 4、头像设置12avatar: url: #/images/avatar.gif 然后将准备好的gif图片放入*next/source/images/中即可。PS：暂时没找到喜欢的图，这个还没弄~ 5、warning: LF will be replaced by CRLF in XXXXXXhexo d时遇到这个警告，大概是各平台间的\n\r问题，用一下代码解决： 1$ git config --global core.autocrlf false ::永久禁]]></content>
      <tags>
        <tag>Helper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OJ大数整除]]></title>
    <url>%2F2019%2F07%2F04%2Ffirst%2F</url>
    <content type="text"><![CDATA[原题链接http://www.dotcpp.com/oj/problem1074.html 题目描述定理：把一个至少两位的正整数的个位数字去掉，再从余下的数中减去个位数的5倍。当且仅当差是17的倍数时，原数也是17的倍数 。 例如，34是17的倍数，因为3-20=-17是17的倍数；201不是17的倍数，因为20-5=15不是17的倍数。输入一个正整数n，你的任务是判断它是否是17的倍数。 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=10^100），表示待判断的正整数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示相应的n是否是17的倍数。1表示是，0表示否。 样例输入34201209876541317171717171717171717171717171717171717171717171717180 样例输出1010 题目分析：不要用这个定理，否则要处理大数会很麻烦。 直接用小学列式除法的原理，从高位到低位依次读入数字，得到每一次的余数r （r中刷新地保存每次的余数），直到大数所有位数被读一遍。最后判断r是否为0，为0则说明刚好被17整除。 代码：123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123; string str; int i; while (cin &gt;&gt; str) &#123; //读入这个大数（2345 if (str[0] == '0') return -1; //为0则退出 int m, r=0; //m表示每一次的被除数，r表示每一次的余数 for (i = 0; i &lt; str.length(); i++) &#123; //遍历这个大数 m = r*10 + str[i] - '0'; //（2,23,64,135 r = m % 17; //（2,6,13,16 &#125; if (r) cout &lt;&lt; '0' &lt;&lt; endl; //r不为0，不能被17整除 else cout &lt;&lt; '1' &lt;&lt; endl; //r为0，能被17整除 &#125; //system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Clean1$ hexo clean Generate static files1$ hexo generate More info: Generating Run server1$ hexo server #本地查看 More info: Server Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
