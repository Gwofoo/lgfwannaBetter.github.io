<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js学习笔记]]></title>
    <url>%2F2019%2F07%2F07%2Fjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[分号在 JavaScript 中，用分号来结束语句是可选的。 对代码行进行拆行可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示： 12document.write("你好 \世界!"); 不过，不能像这样拆行： 12document.write \ ("你好世界!"); 注释采用 // 和 /* */ 两种。 变量声明JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。 当您声明新变量时，可以使用 “new” 来声明其类型（首字母大写）： 12345var carname = new String; //字符串var x = new Number; //数字 var y = new Boolean; //布尔var cars = new Array; //数组var person = new Object; //对象 赋值1var x,y,z=1; x, y 为 undefined， z 为 1。 重新声明如果重新声明 JavaScript 变量，该变量的值不会丢失： 12var carname="Volvo"; var carname; 两条语句执行后，变量 carname 的值依然是 “Volvo”。 生存期局部变量（函数内的变量，只能在函数内部访问它）会在函数运行以后被删除。 全局变量（函数外的变量，网页上的所有脚本和函数都能访问它）会在页面关闭后被删除。 向未声明的 JavaScript 变量分配值如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 这条语句： 1carname="Volvo"; 将声明 window 的一个属性 carname。 非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。 123456789101112var var1 = 1; // 不可配置全局属性var2 = 2; // 没有使用 var 声明，可配置全局属性console.log(this.var1); // 1console.log(window.var1); // 1delete var1; // false 无法删除console.log(var1); //1delete var2; console.log(delete var2); // trueconsole.log(var2); // 已经删除 报错变量未定义 数组创建名为 cars 的数组： 1234var cars=new Array();cars[0]="Saab";cars[1]="Volvo";cars[2]="BMW"; 或者 (condensed array，压缩数组): 1var cars=new Array("Saab","Volvo","BMW"); 或者 (literal array，文本数组): 1var cars=["Saab","Volvo","BMW"]; 对象对象由花括号分隔。对象的属性以 name : value 的形式来定义。属性由逗号分隔： 123456789var person=&#123; firstname : "John", //在对象中写属性 lastname : "Doe", id : 5566, fullName : function() //在对象中写方法 &#123; return this.firstName + " " + this.lastName; &#125;&#125;; 对象属性有两种寻址方式： 12name = person.lastname;name = person["lastname"]; 调用对象的方法： 123456name = person.fullName(); //执行函数，返回：John Doename = person.fullName; //返回：function() &#123; return this.firstName + " " + this.lastName; &#125;//调用方法时，不加括号，返回的是函数代码（相当于把方法看成属性了） undefined 、null、typeofundefined ： ​ 表示变量不含有值。 ​ 是所有没有赋值变量的默认值，自动赋值。 null： ​ 可以将变量的值设置为 null 来清空变量。 ​ 主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 可以使用 typeof 操作符来检测变量的数据类型。 123456//null 和 undefined 的值相等，但类型不等：typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 函数函数变量变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 12345// 此处可调用 carName 变量 function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量 &#125; 该例中， carName 在函数内，但是为全局变量。 匿名函数函数存储在变量中，不需要函数名称，通常通过变量名来调用。 12var x = function (a, b) &#123;return a * b&#125;;var z = x(4, 3); 自调用函数（还不太理解）函数表达式可以 “自调用”。 自调用表达式会自动调用。 如果表达式后面紧跟 () ，则会自动调用。 不能自调用声明的函数。 通过添加括号，来说明它是一个函数表达式： 123(function () &#123; var x = "Hello!!"; // 我将调用自己&#125;)(); 以上函数实际上是一个 匿名自我调用的函数 (没有函数名)。 JavaScript 闭包实例 1234567var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125; &#125;)(); add(); add(); add(); // 计数器为 3 实例解析 变量 add 指定了函数自我调用的返回字值。 自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。 add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 计数器受匿名函数的作用域保护，只能通过 add 方法修改。函数是对象 在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。 箭头函数ES6 新增了箭头函数。箭头函数的语法比普通函数更简洁。 1234(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125; 当只有一个参数时，圆括号是可选的： 12(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125; 没有参数的函数应该写成一对圆括号: 1() =&gt; &#123;函数声明&#125; 实例： 123456// ES5 var x = function(x, y) &#123; return x * y; &#125; // ES6 const x = (x, y) =&gt; x * y; 参数规则显式参数（形参）、隐式参数（实参） JavaScript 函数定义显式参数时没有指定数据类型。 JavaScript 函数对隐式参数没有进行类型检测。 JavaScript 函数对隐式参数的个数没有进行检测。 let关键字let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。 let 和 var 的区别代码实例： 1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量: 1234567var x = 2; // 合法let x = 3; // 不合法&#123; var x = 4; // 合法 let x = 5 // 不合法&#125; const关键字使用 const 声明的是常量，其值一旦被设定便不可被更改。 常见的HTML事件下面是一些常见的HTML事件的列表: 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 字符串字符串可以是对象通常， JavaScript 字符串是原始值，可以使用字符创建： 1var x = "John" 但我们也可以使用 new 关键字将字符串定义为一个对象： 1var y = new String("John") 12typeof x // 返回 Stringtypeof y // 返回 Object 建议：不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用： 12345678var x = "John"; var y = new String("John");(x === y) /* 结果为 false，因为 x 是字符串，y 是对象 === 为绝对相等，即数据类型与值都必须相等。*/ 关于更多字符串对象，请访问菜鸟String对象 For/In 循环for/in 语句循环遍历对象的属性： 123456var person=&#123;fname:"John",lname:"Doe",age:25&#125;; for (x in person) &#123; // x 为属性名 txt=txt + person[x]; &#125;//txt最终为：JohnDoe25 js数据类型在 JavaScript 中有 5 种不同的数据类型： string number boolean object function 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined 请注意： NaN 的数据类型是 number 数组(Array)的数据类型是 object 日期(Date)的数据类型为 object null 的数据类型是 object 未定义变量的数据类型为 undefined 类型转换123456789101112String(x) // 将变量 x 转换为字符串并返回x.toString()Number("3.14") // 返回 3.14Number(" ") // 返回 0 Number("") // 返回 0Number("99 88") // 返回 NaN5 + null // 返回 5 null 转换为 0"5" + null // 返回"5null" null 转换为 "null""5" + 1 // 返回 "51" 1 转换为 "1" "5" - 1 // 返回 4 "5" 转换为 5 提升（hoisting）提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的行为。提升（Hoisting）应用在变量的声明与函数的声明。 变量提升JavaScript 中，函数及变量的声明总是会被解释器悄悄地被”提升”到函数的最顶部。也就是说，哪怕变量在使用后才声明，也没事（有声明就好~）。 但 声明的时候顺便初始化了（如var y = 7;），此时不会被“提升”。 函数提升函数可以在声明之前调用： 12345myFunction(5); //先调用function myFunction(y) &#123; //再声明 return y * y;&#125; 使用表达式定义函数时无法提升。 “use strict”JavaScript 严格模式（strict mode）即在严格的条件下运行。 实例1 123456"use strict";myFunction();function myFunction() &#123; y = 3.14; // 报错 (y 未定义)&#125; 实例2 1234567x = 3.14; // 不报错 myFunction();function myFunction() &#123; "use strict"; y = 3.14; // 报错 (y 未定义)&#125; 为什么使用严格模式: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 更多限制，点击此处 浮点型数据JavaScript 中的所有数据都是以 64 位浮点型数据(float) 来存储。 所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定： 1234var x = 0.1;var y = 0.2;var z = x + y // z 的结果为 0.3if (z == 0.3) // 返回 false JavaScript 表单JavaScript 表单]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Helper]]></title>
    <url>%2F2019%2F07%2F04%2FMarkdown-Helper%2F</url>
    <content type="text"><![CDATA[Markdown是一种神奇的标记语言，对我这种格式强迫症患者具有很好的治疗效果！通过简单的标记语法，它可以使普通文本内容具有一定的格式。以下是日常使用总结，持续更新~ Markdown 需要转义的字符123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT Helper]]></title>
    <url>%2F2019%2F07%2F04%2FNexT-Helper%2F</url>
    <content type="text"><![CDATA[嘻嘻！装了我很喜欢的也是几乎最热门的主题NexT，但是相关配置还是花了一点时间，现在将一些主要设置写于此博客\便于日后修改~ 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。以下设置大部分是对该文件的设置。 1、文章设置给文章增加标签打开文章的.md文件，在最上面写上： 1234title: 文章名称tags: - Tag1 - Tag2 禁用评论打开文章的.md文件，在最上面写上： 1comments: false 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供选择。 默认使用的是 白色的 normal 主题，可选的值有 : normal，night， night blue， night bright， night eighties, 如下图所示： 修改：在NexT下的_config.yml中设置 1highlight_theme: normal 添加阅读全文按钮只需在文章中你想截止的地方添加 1&lt;!--more--&gt; 2、菜单设置添加模块123456789menu: home: / || home //首页，默认 archives: /archives/ || archive //归档，默认 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 不需要哪个就将其注释掉。 仅仅这设置的话点击后会类似于404，还要添加相应的页面语句。在blog根目录右键打开git bash，利用 123$ hexo new page tags ::新建标签$ hexo new page categories ::新建分类$ hexo new page about ::新建关于 在blog/sourse/下新建相关文件。 添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 3、主题设置我设置的是 pieces， 共有4中可选，默认是Muse。 12345# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 4、头像设置12avatar: url: #/images/avatar.gif 然后将准备好的gif图片放入*next/source/images/中即可。PS：暂时没找到喜欢的图，这个还没弄~]]></content>
      <tags>
        <tag>Helper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OJ大数整除]]></title>
    <url>%2F2019%2F07%2F04%2Ffirst%2F</url>
    <content type="text"><![CDATA[原题链接http://www.dotcpp.com/oj/problem1074.html 题目描述定理：把一个至少两位的正整数的个位数字去掉，再从余下的数中减去个位数的5倍。当且仅当差是17的倍数时，原数也是17的倍数 。 例如，34是17的倍数，因为3-20=-17是17的倍数；201不是17的倍数，因为20-5=15不是17的倍数。输入一个正整数n，你的任务是判断它是否是17的倍数。 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=10^100），表示待判断的正整数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示相应的n是否是17的倍数。1表示是，0表示否。 样例输入34201209876541317171717171717171717171717171717171717171717171717180 样例输出1010 题目分析：不要用这个定理，否则要处理大数会很麻烦。 直接用小学列式除法的原理，从高位到低位依次读入数字，得到每一次的余数r （r中刷新地保存每次的余数），直到大数所有位数被读一遍。最后判断r是否为0，为0则说明刚好被17整除。 代码：123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123; string str; int i; while (cin &gt;&gt; str) &#123; //读入这个大数（2345 if (str[0] == '0') return -1; //为0则退出 int m, r=0; //m表示每一次的被除数，r表示每一次的余数 for (i = 0; i &lt; str.length(); i++) &#123; //遍历这个大数 m = r*10 + str[i] - '0'; //（2,23,64,135 r = m % 17; //（2,6,13,16 &#125; if (r) cout &lt;&lt; '0' &lt;&lt; endl; //r不为0，不能被17整除 else cout &lt;&lt; '1' &lt;&lt; endl; //r为0，能被17整除 &#125; //system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
